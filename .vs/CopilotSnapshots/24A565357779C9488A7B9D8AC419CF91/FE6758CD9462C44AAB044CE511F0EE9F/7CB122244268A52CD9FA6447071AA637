using ShoppingListAW4E.Models;
using ShoppingListAW4E.ViewModels;
using System;

namespace ShoppingListAW4E.Views
{
    // ProductView to widok prezentujący pojedynczy produkt na liście.
    // Bardzo szczegółowe komentarze (krok po kroku):
    // - Ten plik zawiera funkcje, które są wywoływane, kiedy użytkownik kliknie
    // przyciski widoczne obok produktu (zmniejsz/zmniejsz ilość, kupione, usuń).
    // - Każdy widok ma swój "BindingContext" — to obiekt (tutaj Product), z którego
    // pobieramy dane do wyświetlenia. Metody tutaj odczytują i modyfikują ten obiekt.
    public partial class ProductView : ContentView
    {
        public ProductView()
        {
            InitializeComponent();
        }

        // Zmniejsz ilość o1, jeśli jest większa niż0.
        // Wyjaśnienie:
        // - BindingContext to obiekt powiązany z tym widokiem, czyli dany produkt.
        // - Najpierw sprawdzamy, czy BindingContext faktycznie zawiera Product,
        // a potem zmieniamy jego właściwość Quantity.
        void OnDecreaseClicked(object sender, EventArgs e)
        {
            if (BindingContext is Product product && product.Quantity >0)
            {
                product.Quantity--;
            }
        }

        // Zwiększ ilość o1.
        void OnIncreaseClicked(object sender, EventArgs e)
        {
            if (BindingContext is Product product)
            {
                product.Quantity++;
            }
        }

        // Obsługa oznaczania produktu jako kupionego/odznaczenia.
        // Szczegółowe wyjaśnienie dlaczego szukamy ViewModelu:
        // - Logika aplikacji (np. zmiana kolejności na liście i zapis) nie powinna
        // być w pliku widoku. Dlatego znajdujemy ViewModel (ShoppingListViewModel)
        // i prosimy go, aby wykonał operację. To pozwala oddzielić "co widzimy" od "co aplikacja robi".
        // - Aby odnaleźć ViewModel, idziemy w górę po hierarchii obiektów interfejsu
        // aż do elementu typu ContentPage, którego BindingContext to właśnie ViewModel.
        void OnBoughtClicked(object sender, EventArgs e)
        {
            if (BindingContext is not Product product)
                return;

            Element parent = this.Parent;
            while (parent != null && parent is not ContentPage)
                parent = parent.Parent;

            if (parent is ContentPage page && page.BindingContext is ShoppingListViewModel vm)
            {
                // Prosimy ViewModel o zmianę stanu produktu i aktualizację list.
                vm.ToggleBought(product);

                try
                {
                    // Dodatkowo próbujemy przewinąć listę (CollectionView) aby użytkownik
                    // widział efekt przeniesienia produktu na koniec listy (dla kupionych).
                    Element el = this;
                    while (el != null && el is not CollectionView)
                        el = el.Parent;

                    if (el is CollectionView cv)
                    {
                        cv.ScrollTo(product, position: ScrollToPosition.End, animate: true);
                    }
                }
                catch
                {
                    // Jeśli przewinięcie nie powiedzie się (np. struktura widoków jest inna),
                    // to nic złego — operacja główna (oznaczenie jako kupione) została wykonana.
                }
            }
        }

        // Usuwanie produktu: podobnie jak powyżej, prosimy ViewModel o usunięcie
        // ponieważ on zarządza listami i zapisami.
        void OnRemoveClicked(object sender, EventArgs e)
        {
            Element parent = this.Parent;
            while (parent != null && parent is not ContentPage)
                parent = parent.Parent;

            if (parent is ContentPage page && page.BindingContext is ShoppingListViewModel vm && BindingContext is Product product)
            {
                vm.RemoveProduct(product);
            }
        }
    }
}
